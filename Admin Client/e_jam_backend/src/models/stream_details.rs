use chrono::{Utc, DateTime, serde::{ts_seconds_option, ts_seconds}};
use serde::{Deserialize, Serialize};
use validator::Validate;
use super::{STREAM_ID, StreamStatus};

#[doc = r" # Stream Details
The StreamDetails struct is used to store the information about the stream that is sent to the device to start or queue the stream
## Values
* `stream_id` - A String that represents the id of the stream that is used to identify the stream in the device, must be alphanumeric, max is 3 bytes (36^3 = 46656)
* `delay` - A u64 that represents the time in ms that the stream will wait before starting
* `time_to_live` - A u64 that represents the time to live that will be used for the stream
* `inter_frame_gap` - A u32 that represents the time in ms that will be waited between each frame
* `generators` - A Vec of String that has all the mac addresses of the devices that will generate the stream
* `verifiers` - A Vec of String that has all the mac addresses of the devices that will verify the stream
* `number_of_packets` - A u32 that represents the number of packets that will be sent in the stream
* `broadcast_frames` - A u32 that represents the number of broadcast frames that will be sent in the stream
* `payload_length` - A u16 that represents the length of the payload that will be used in the stream
* `payload_type` - A u8 that represents the type of the payload that will be used in the stream (0, 1, 2)
* `burst_length` - A u64 that represents the number of packets that will be sent in a burst
* `burst_delay` - A u64 that represents the time in ms that will be waited between each burst
* `seed` - A u32 that represents the seed that will be used to generate the payload
* `flow_type` - A u8 that represents the flow type that will be used for the stream (0 = BtB, 1 = Bursts)
* `transport_layer_protocol` - A u8 that represents the transport layer protocol that will be used for the stream (0 = TCP, 1 = UDP)
* `check_content` - A bool that represents if the content of the packets will be checked"]
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct StreamDetails {
    pub stream_id: String,
    pub delay: u64,
    pub generators: Vec<String>,
    pub verifiers: Vec<String>,
    pub payload_type: u8,
    pub number_of_packets: u32,
    pub payload_length: u64,
    pub burst_length: u64,
    pub burst_delay: u64, 
    pub seed: u64,
    pub broadcast_frames: u32,
    pub inter_frame_gap: u64,
    pub time_to_live: u64,
    pub transport_layer_protocol: u8,
    pub flow_type: u8,
    pub check_content: bool,
}

#[derive(Validate, Serialize, Deserialize, Default, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct StreamStatusDetails {
    #[doc = r" ## Name
    Name of the stream (used for clarification)
    ## Constraints
    * The name must be greater than 0 characters long
    * The name must be less than 50 characters long
    "]
    #[validate(length(
        min = 1,
        max = 50,
        message = "Name must be between 1 and 50 characters long"
    ))]
    pub name: String,


    #[doc = r" ## Stream ID
    This is the id of the stream that is used to identify the stream in the device, must be alphanumeric, max is 3 characters
    The stream id is generated by the server and is unique or can be given by the user (if the user gives the id it must be unique)
    ## Constraints
    * Must be given (length is 3)
    * Must be alphanumeric (a-z (only by user), A-Z, 0-9)
    * check the regex `STREAM_ID` for more details
    "]
    #[validate(regex(
        path = "STREAM_ID",
        message = "Stream ID must be alphanumeric and 3 characters long"
    ))]
    #[serde(default)]
    pub stream_id: String,

    #[doc = r" ## Stream Status
    This is the state that the stream is in at any given time in the system (see the state machine below)
    ## see also
    The stream state machine: ./docs/stream_state_machine.png"]
    #[serde(default, skip_deserializing)]
    pub stream_status: StreamStatus,

    #[doc = r" ## Last Updated
    Last time that the stream was updated
    this is updated when the stream Status is updated by the server
    "]
    #[serde(with = "ts_seconds")]
    #[serde(default, skip_deserializing)]
    pub last_updated: DateTime<Utc>,

    #[doc = r" ## Start Time
    This is updated when the stream is started with the time the first device starts the stream
    This is an optional field and can be left empty and will be updated automatically when the stream is first started
    "]
    #[serde(default, skip_deserializing)]
    #[serde(with = "ts_seconds_option")]
    pub start_time: Option<DateTime<Utc>>,

    #[doc = r" ## End Time
    This is updated when the stream is finished with the time the last device finishes the stream
    This is an optional field and can be left empty and will be updated automatically when the stream is last finished
    "]
    #[serde(default, skip_deserializing)]
    #[serde(with = "ts_seconds_option")]
    pub end_time: Option<DateTime<Utc>>,
}
